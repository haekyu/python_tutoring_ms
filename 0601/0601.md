### Overview
- Time complexity
- 재귀함수
- 파일 읽고 쓰기

### Time complexity
- 시간 복잡도. 알고리즘이 대강 어느정도의 시간이 걸리는지를 의미.
- O-notation (Large O notation)
    - Time complexity 표기법
    - 예) O(n): 대충 n의 시간이 걸린다.
    - 상수 coefficient는 무시
        - O(n) == O(2n)


### 재귀함수 (Recursive function)
- 어떤 함수를 정의할 때 자기 자신을 정의에 사용하는 경우, 이 함수를 재귀함수라고 함.
    - 예) 피보나치 함수: `fib(n) = fib(n-2) + fib(n-1)`
- 재귀 함수의 구성 요소
    - *초기 조건*
    - 재귀 식
- 예1) 피보나치 함수
    ```python
        def fib(n):
            # 초기 조건
            if (n == 0) or (n == 1):
                result = 1

            # 재귀 식
            else:
                result = fib(n - 2) + fib(n - 1)
            return result
    ```
- 예2) factorial 함수
    ```python
    def fac(n):
        # 초기 조건
        if n == 1:
            result = 1

        # 재귀 식
        else:
            result = n * fac(n - 1)

        return result
    ```
- 그러나... 재귀함수를 그냥 짜면 너무나도 느리다 ㅠ
    - 중복 계산이 너무 많이 일어나기 때문
    - 해결방법! 중복 계산을 없애자!
        - Dynamic programming (O)
        - 이전에 계산해둔 값을 저장하고 꺼내오는 형식
        - 저장소: reservoir
    - Tail recursion (X)
        - 다음 시간




### 파일 경로
- 절대경로
    - 서울특별시 관악구 신림동 서울대학교 ...
    - 
- 상대경로
    - 내 위치에서 오른쪽으로 한 칸
    - .: 현재 위치
    - ..: 상위 경로
    - 하위 경로는 이름을 지어주면 됨




## 파일 읽고 쓰기
- 파일 객체
    - f = open(파일 이름, mode=...)
        - mode: 
            - 'r' : read
            - 'w' : write
            - 'a' : append
    - lst = f.readlines()
    - f.close()





## Dictionary
- key
- val
- d[key] = val
- d.values()
- val = d[key]

d = {'p': ['print', 'person'], 'a': ['apple', 'aurora'], 'b': ['bear', 'boy']}
d.values() --> [['print', 'person'], ['apple', 'aurora'], ['bear', 'boy']]

## List에 원소 추가하기
lst = []
lst.append(element)

## Default dictionary
from collections import defaultdict

dd = defaultdict(lambda: ????)


## sdfsdf
call by reference

call by value

